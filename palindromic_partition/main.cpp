#include <bits/stdc++.h>
using namespace std;

bool ispalindrome(string str, int low , int high){
    //if palindrome so first and last will be equal
    //then first ++ last-- then again check
    while (low < high){
        if(str[low] != str[high]) return false;
        low ++;
        high --;
    }
return true;
}

//recursive function to find all palindromic partitions of str
//all part --> every vector inside it stores a partition   
//currpart --> a vector of string to store current partition
void allpalindromepart(vector <vector <string>> &allPart,vector <string> &currPart,int start,int n,string str){
    
    //if 'start' has reached len 
    if(start >= n){
        allPart.push_back(currPart);
        return;
        }
    
    // Pick all possible ending points for substrings
    for(int i = start; i < n; i ++){
        if(ispalindrome(str,start,i)){
            
            //add the substring to result 
            currPart.push_back(str.substr(start,i - start + 1));
            
            //recur for remainning substring 
            allpalindromepart(allPart ,currPart ,i + 1 ,n ,str);
            
            //remove substring str[start...i] from current
            //partition
            currPart.pop_back();
        }
    }
}

//function to print all possible palindromic partitions of 
//str.it mainly creates vector  and calls allpalindromepart()
void allpalpart(string str){
    int n = str.length();
    
    //to store all  palindrome partitions
    vector< vector <string> > allPart;
    
    //to store current palindrome partitions 
    vector <string> currPart;
    
    // call recursive function to generate all partitions
    //and store in allpart
    allpalindromepart(allPart,currPart,0,n,str);
    
    //print all partitions generated by above call
    for(int i = 0;i < allPart.size();i ++){
        for(int j = 0; j < allPart[i].size();j ++) 
            cout << allPart[i][j] << " ";
    cout<< "\n";
    }
} 
int main(){
	string str = "dillid";
    allpalpart(str);
	return 0;
}
